 //////////http://spark.apache.org/docs/latest/programming-guide.html

Para gerar todas as combinações?
map() 



Adicionar pesos
 foreach(func)


ordenar
takeOrdered(n, [ordering])


Utilizar memory-only

Nao esquecer modulo livre



////////PSEUDO CODE


import org.apache.spark.SparkContext //Necessario pra rodar Spark stuffz
import org.apache.spark.SparkConf


bloco = sc.~~ pega list<Disciplina>(aluno); //funcao de carga do conteudo do aluno e historico a definir

Class Grades : Disciplina /////Classe Manipula as informações do algoritmo
{
List<Disciplinas> listaOrdenada;
List<Disciplina,int> pertencentes ;
Array<int> horario;
int metricaTotal;
int totalCreditos;

public Grades(List<Disciplinas> l= new List<Disciplinas>(),List<Disciplina,int> p= new List<Disciplina,int>(){},Array<int> h=new array<int>[108], int m= 0,int t=0)
	{
	listaOrdenada = l;
	pertencentes = p;
	horario = h;
	metricaTotal = m;
	totalCreditos = t;
	}

}

private void Disciplina::GeraMetrica(Disciplina D) 
{
	bool valida = true;
	foreach(int C in D.Prerequisitos)	//Varre Prerequisitos para validar a posibilidade de cursar
	{
		if(!historicoAprovado.Contains(C))
			{
			valida = false;	
			}
	}
	if(valida & D.vagas>0) //ja tem pre requisitos e existem vagas
		{
		D.metrica = PerfilporDepartamento(D.departamento,aluno.perfil) + PesoSemestre(D.semestrefluxo,aluno.semestre) + Tipo(D.tipo);
		}
		
}



private Grades GetGrid(Grades grade) //// Funcao geradora da grade final         
{

if(grade.listaOrdenada!=null) // se nao alcancou a folha da arvore  
	{
		Grades selecionado = grade;
		if(grade.listaOrdenada.first().metrica < 30 - grade.total) //existe creditos disponiveis
			{
			sc.foreach(int T in grade.listaOrdenada.first().Turmas) ////Paralelismo das arvores para cada turma da disciplina em questão
				{  
					Grades auxInclude,auxExclude,auxSelecionado = new Grades(null,horario);
					bool valid = true;
					foreach(int h in T.horarios)
						{
							if(horario[h-1]!=0)
							{ valid=false;}
						}
					if(valid)
						{
						foreach(int h in T.horarios) //se valido altera horario
							{
								auxSelecionado.horario[h]==grade.listaOrdenada.first().codigoDisciplina;
							}
						//Ramo que inclui essa disciplina
						auxInclude = GetGrid(new Grades(grade.listaOrdenada.Popfirst(),
							grade.pertencente.append(grade.listaOrdenada.first(),T),
							auxSelecionado.horario,
							metricaTotal+grade.listaOrdenada.first().metrica,
							totalCreditos+grade.listaOrdenada.first().credito));

						if(grade.grade.listaOrdenada.first().metrica<100) //Poda soluções das arvores, exclue ramos que não incluem disciplinas mandatorias
							{
							auxExclude = GetGrid(new Grades(grade.listaOrdenada.Popfirst(),
							grade.pertencente,
							horario,
							metricaTotal,
							totalCreditos));
							}
						} 
					if(auxExclude.metricaTotal > auxInclude.metricaTotal) //Pega o maior entre as 2 solucões (incluir ou nao)
					{auxSelecionado = auxExclude;}
					else
					{auxSelecionado = auxInclude;}
					if(auxSelecionado.metricaTotal > selecionado.metricaTotal) //Das multiplas interações retorna a melhor
					{selecionado = auxSelecionado;}

			        }
			return selecionado;
			}

		else   ///Se a solução não pode incluir essa disciplinas pois estoura o número de creditos
			{
				selecionado = GetGrid(new Grades(grade.listaOrdenada.Popfirst(),grade.pertencente,grade.horario,grade.metricaTotal,grade.totalCreditos));
			}
			return selecionado;
	}
else
{return grade;}
	
}

disciplineList = bloco.map(lambda d -> d.GeraMetrica()).filter(d -> d.metrica>0); // varre entradas, atribui pesos e filtra apenas elementos que podem ser cursados para lista ponderada

orderDisciplineList  = listadisciplinas.takeOrdered(listadiciplinas.lenght(),descending);//ordena
megagrid = new Grades(new List<Disciplinas>orderDisciplineList);//instancia classe inicial
 return grid = GetGrid(megagrid);

